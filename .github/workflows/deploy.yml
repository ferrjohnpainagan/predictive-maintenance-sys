name: Deploy Predictive Maintenance System

on:
  push:
    branches: [main, develop]
    paths:
      - "backend/**"
      - "mlops/**"
      - "shared/**"
      - ".github/workflows/deploy.yml"
  pull_request:
    branches: [main]
    paths:
      - "backend/**"
      - "mlops/**"
      - "shared/**"
  workflow_dispatch:
    inputs:
      environment:
        description: "Deployment Environment"
        required: true
        default: "free-tier"
        type: choice
        options:
          - free-tier
          - staging
          - production
      services:
        description: "Services to Deploy"
        required: true
        default: "all"
        type: choice
        options:
          - all
          - api-gateway
          - ml-service

env:
  AWS_REGION: ap-southeast-1
  EC2_API_GATEWAY_IP: ${{ secrets.EC2_API_GATEWAY_IP }}
  EC2_ML_SERVICE_IP: ${{ secrets.EC2_ML_SERVICE_IP }}
  SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
  SSH_USER: ec2-user
  DOCKER_REGISTRY: ${{ secrets.DOCKER_REGISTRY }}

jobs:
  # Build and Test Phase
  build-and-test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "npm"
          cache-dependency-path: backend/api-gateway/package-lock.json

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"
          cache: "pip"
          cache-dependency-path: mlops/requirements.txt

      - name: Install API Gateway dependencies
        working-directory: backend/api-gateway
        run: |
          npm ci
          npm run lint
          npm run test

      - name: Install ML Service dependencies
        working-directory: mlops
        run: |
          pip install -r requirements.txt
          python -m pytest tests/ --cov=src/

      - name: Run security scan
        run: |
          npm audit --audit-level=moderate || true
          safety check || true

  # Build Docker Images
  build-images:
    needs: build-and-test
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.DOCKER_REGISTRY }}
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build API Gateway image
        uses: docker/build-push-action@v5
        with:
          context: ./backend/api-gateway
          push: true
          tags: |
            ${{ env.DOCKER_REGISTRY }}/api-gateway:${{ github.sha }}
            ${{ env.DOCKER_REGISTRY }}/api-gateway:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build ML Service image
        uses: docker/build-push-action@v5
        with:
          context: ./mlops
          push: true
          tags: |
            ${{ env.DOCKER_REGISTRY }}/ml-service:${{ github.sha }}
            ${{ env.DOCKER_REGISTRY }}/ml-service:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Generate deployment manifest
        run: |
          cat > deployment-manifest.json << EOF
          {
            "deployment_id": "${{ github.run_id }}",
            "timestamp": "${{ github.event.head_commit.timestamp }}",
            "commit_sha": "${{ github.sha }}",
            "commit_message": "${{ github.event.head_commit.message }}",
            "images": {
              "api_gateway": "${{ env.DOCKER_REGISTRY }}/api-gateway:${{ github.sha }}",
              "ml_service": "${{ env.DOCKER_REGISTRY }}/ml-service:${{ github.sha }}"
            }
          }
          EOF

      - name: Upload deployment manifest
        uses: actions/upload-artifact@v4
        with:
          name: deployment-manifest
          path: deployment-manifest.json

  # Deploy to API Gateway
  deploy-api-gateway:
    needs: build-images
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.services == 'all' || github.event.inputs.services == 'api-gateway' }}
    steps:
      - name: Download deployment manifest
        uses: actions/download-artifact@v4
        with:
          name: deployment-manifest

      - name: Deploy API Gateway
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ env.EC2_API_GATEWAY_IP }}
          username: ${{ env.SSH_USER }}
          key: ${{ env.SSH_PRIVATE_KEY }}
          port: 22
          script: |
            # Set deployment variables
            DEPLOYMENT_ID="${{ github.run_id }}"
            IMAGE_TAG="${{ github.sha }}"
            DOCKER_REGISTRY="${{ env.DOCKER_REGISTRY }}"

            # Create deployment log
            echo "Starting API Gateway deployment: $DEPLOYMENT_ID at $(date)" >> /var/log/deployment.log

            # Navigate to service directory
            cd /opt/api-gateway

            # Backup current configuration
            if [ -f docker-compose.yml ]; then
              cp docker-compose.yml docker-compose.yml.backup.$(date +%Y%m%d_%H%M%S)
            fi

            # Update docker-compose.yml with new image
            cat > docker-compose.yml << 'EOF'
            version: '3.8'
            services:
              api-gateway:
                image: $DOCKER_REGISTRY/api-gateway:$IMAGE_TAG
                ports: ["3000:3000"]
                environment: 
                  - NODE_ENV=production
                  - PORT=3000
                  - DEPLOYMENT_ID=$DEPLOYMENT_ID
                restart: unless-stopped
                healthcheck:
                  test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
                  interval: 30s
                  timeout: 10s
                  retries: 3
                  start_period: 40s
            EOF

            # Pull new image
            docker-compose pull

            # Stop existing service
            docker-compose down

            # Start new service
            docker-compose up -d

            # Wait for service to be healthy
            echo "Waiting for API Gateway to be healthy..." >> /var/log/deployment.log
            for i in {1..30}; do
              if curl -f http://localhost:3000/health > /dev/null 2>&1; then
                echo "API Gateway is healthy after $i attempts" >> /var/log/deployment.log
                break
              fi
              if [ $i -eq 30 ]; then
                echo "ERROR: API Gateway failed health check after 30 attempts" >> /var/log/deployment.log
                exit 1
              fi
              sleep 2
            done

            # Verify deployment
            docker-compose ps
            curl -f http://localhost:3000/health

            echo "API Gateway deployment completed successfully: $DEPLOYMENT_ID at $(date)" >> /var/log/deployment.log

      - name: Verify API Gateway deployment
        run: |
          echo "Verifying API Gateway deployment..."
          sleep 10
          curl -f http://${{ env.EC2_API_GATEWAY_IP }}:3000/health || exit 1
          echo "✅ API Gateway deployment verified successfully!"

  # Deploy to ML Service
  deploy-ml-service:
    needs: build-images
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.services == 'all' || github.event.inputs.services == 'ml-service' }}
    steps:
      - name: Download deployment manifest
        uses: actions/download-artifact@v4
        with:
          name: deployment-manifest

      - name: Deploy ML Service
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ env.EC2_ML_SERVICE_IP }}
          username: ${{ env.SSH_USER }}
          key: ${{ env.SSH_PRIVATE_KEY }}
          port: 22
          script: |
            # Set deployment variables
            DEPLOYMENT_ID="${{ github.run_id }}"
            IMAGE_TAG="${{ github.sha }}"
            DOCKER_REGISTRY="${{ env.DOCKER_REGISTRY }}"

            # Create deployment log
            echo "Starting ML Service deployment: $DEPLOYMENT_ID at $(date)" >> /var/log/deployment.log

            # Navigate to service directory
            cd /opt/ml-service

            # Backup current configuration
            if [ -f docker-compose.yml ]; then
              cp docker-compose.yml docker-compose.yml.backup.$(date +%Y%m%d_%H%M%S)
            fi

            # Update docker-compose.yml with new image
            cat > docker-compose.yml << 'EOF'
            version: '3.8'
            services:
              ml-service:
                image: $DOCKER_REGISTRY/ml-service:$IMAGE_TAG
                ports: ["8000:8000", "50051:50051"]
                environment: 
                  - ENVIRONMENT=production
                  - PORT=8000
                  - GRPC_PORT=50051
                  - DEPLOYMENT_ID=$DEPLOYMENT_ID
                restart: unless-stopped
                healthcheck:
                  test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
                  interval: 30s
                  timeout: 10s
                  retries: 3
                  start_period: 40s
            EOF

            # Pull new image
            docker-compose pull

            # Stop existing service
            docker-compose down

            # Start new service
            docker-compose up -d

            # Wait for service to be healthy
            echo "Waiting for ML Service to be healthy..." >> /var/log/deployment.log
            for i in {1..30}; do
              if curl -f http://localhost:8000/health > /dev/null 2>&1; then
                echo "ML Service is healthy after $i attempts" >> /var/log/deployment.log
                break
              fi
              if [ $i -eq 30 ]; then
                echo "ERROR: ML Service failed health check after 30 attempts" >> /var/log/deployment.log
                exit 1
              fi
              sleep 2
            done

            # Verify deployment
            docker-compose ps
            curl -f http://localhost:8000/health

            echo "ML Service deployment completed successfully: $DEPLOYMENT_ID at $(date)" >> /var/log/deployment.log

      - name: Verify ML Service deployment
        run: |
          echo "Verifying ML Service deployment..."
          sleep 10
          curl -f http://${{ env.EC2_ML_SERVICE_IP }}:8000/health || exit 1
          echo "✅ ML Service deployment verified successfully!"

  # Post-deployment verification
  verify-deployment:
    needs: [deploy-api-gateway, deploy-ml-service]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Download deployment manifest
        uses: actions/download-artifact@v4
        with:
          name: deployment-manifest

      - name: Verify both services
        run: |
          echo "🔍 Verifying complete deployment..."

          # Check API Gateway
          echo "Checking API Gateway..."
          if curl -f http://${{ env.EC2_API_GATEWAY_IP }}:3000/health; then
            echo "✅ API Gateway: HEALTHY"
          else
            echo "❌ API Gateway: UNHEALTHY"
            exit 1
          fi

          # Check ML Service
          echo "Checking ML Service..."
          if curl -f http://${{ env.EC2_ML_SERVICE_IP }}:8000/health; then
            echo "✅ ML Service: HEALTHY"
          else
            echo "❌ ML Service: UNHEALTHY"
            exit 1
          fi

          echo "🎉 All services deployed and healthy!"

      - name: Generate deployment report
        if: success()
        run: |
          echo "## 🚀 Deployment Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Deployment ID**: ${{ github.run_id }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Timestamp**: $(date)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Services Deployed:" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ API Gateway: http://${{ env.EC2_API_GATEWAY_IP }}:3000" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ ML Service: http://${{ env.EC2_ML_SERVICE_IP }}:8000" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Health Status:" >> $GITHUB_STEP_SUMMARY
          echo "- API Gateway: HEALTHY" >> $GITHUB_STEP_SUMMARY
          echo "- ML Service: HEALTHY" >> $GITHUB_STEP_SUMMARY

  # Rollback job (manual trigger)
  rollback:
    runs-on: ubuntu-latest
    if: ${{ github.event.inputs.environment == 'rollback' }}
    steps:
      - name: Rollback to previous deployment
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ env.EC2_API_GATEWAY_IP }}
          username: ${{ env.SSH_USER }}
          key: ${{ env.SSH_PRIVATE_KEY }}
          script: |
            echo "🔄 Starting rollback process..."
            cd /opt/api-gateway

            # Check for backup files
            if [ -f docker-compose.yml.backup.* ]; then
              # Get most recent backup
              LATEST_BACKUP=$(ls -t docker-compose.yml.backup.* | head -1)
              echo "Rolling back to: $LATEST_BACKUP"
              
              # Restore backup
              cp "$LATEST_BACKUP" docker-compose.yml
              
              # Restart service
              docker-compose down
              docker-compose up -d
              
              # Verify rollback
              sleep 10
              if curl -f http://localhost:3000/health; then
                echo "✅ Rollback successful!"
              else
                echo "❌ Rollback failed!"
                exit 1
              fi
            else
              echo "No backup files found for rollback"
              exit 1
            fi
